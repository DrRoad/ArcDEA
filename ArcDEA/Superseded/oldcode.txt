//#region Download fmask data to temporary folder
//// Set progressor
//RefreshProgressBar(1, items.Count, "Downloading fmask data...", false);

//// Download fmask geotiffs to temporary folder
//int i = 0;
//await QueuedTask.Run(() => Parallel.ForEachAsync(items, paraDownloadOptions, async (item, token) =>
//{
//    using (var response = await client.GetAsync(item.MaskWcsUrl))
//    {
//        response.EnsureSuccessStatusCode(); // TODO: handle exception

//        string filepath = Path.Join(tmpFolder, item.MaskFilename);
//        using (FileStream fs = new FileStream(filepath, FileMode.CreateNew))
//        {
//            await response.Content.CopyToAsync(fs);  // TODO: handle exception
//        }
//    }

//    // Increment progress 
//    i = i + 1;
//    if (i % 5 == 0)
//    {
//        progressValue.Report(i);
//        progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
//    }
//}));
//#endregion

//#region Check and remove fmask data for invalid scenes
//// Set progressor
//RefreshProgressBar(1, items.Count, "Removing invalid data via fmask...", false);
//ProgressPercentage = "";

//// Establish connection to temporary folder
//Uri folderUri = new Uri(tmpFolder);
//FileSystemConnectionPath tmpConn = new FileSystemConnectionPath(folderUri, FileSystemDatastoreType.Raster);

//i = 0;
//await QueuedTask.Run(() => Parallel.ForEach(items, paraProcessingOptions, (item, token) =>
//{
//    // New data store connection
//    FileSystemDatastore store = new FileSystemDatastore(tmpConn);

//    // Read raster from store
//    RasterDataset rasterDataset = store.OpenDataset<RasterDataset>(item.MaskFilename);
//    Raster raster = rasterDataset.CreateFullRaster();

//    // Get distinct pixel value counts for raster
//    Dictionary<string, double> percents = Data.GetPercentValidPixels(raster, validClasses);

//    // Flag image as invalid if all overlap or < min valid threshold
//    item.Valid = true;
//    if (percents["pctOverlap"] == 1 || percents["pctValid"] < minValid)
//    {
//        item.Valid = false;
//    }

//    // TODO: Delete image for current item
//    //

//    // Increment progress 
//    i = i + 1;
//    if (i % 5 == 0)
//    {
//        progressValue.Report(i);
//        progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
//    }
//}));

//// Remove invalid dates
//items = items.Where(e => e.Valid == true).ToList();
//#endregion

//#region Download valid data to temporary folder
//// Set progressor
//RefreshProgressBar(1, items.Count, "Downloading satellite data...", false);
//ProgressPercentage = "";

//// Download satellite geotiffs to temporary folder
//i = 0;
//await QueuedTask.Run(() => Parallel.ForEachAsync(items, paraDownloadOptions, async (item, token) =>
//{
//    using (var response = await client.GetAsync(item.FullWcsUrl))
//    {
//        response.EnsureSuccessStatusCode(); // TODO: handle exception

//        string filepath = Path.Join(tmpFolder, item.FullFilename);
//        using (FileStream fs = new FileStream(filepath, FileMode.CreateNew))
//        {
//            await response.Content.CopyToAsync(fs);  // TODO: handle exception
//        }
//    }

//    // Increment progress
//    i = i + 1;
//    progressValue.Report(i);
//    progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
//}));
//#endregion


#############################################################

// Set current item validity to false until proven otherwise
item.Valid = false;

// Download mask geotiff and calculate percent valid and overlap.
// Flag image as valid if not all overlap pixels or >= min valid threshold
// Returns null if error.Will retry several times until max retries reached.
for (int j = 0; j < numRetries; j++)
{
    Dictionary<string, float> result = item.DownloadAndCheckMaskValidity(validClasses, client);
    if (result != null)
    {
        if (result["pctOverlap"] < 1.0 && result["pctValid"] >= minValid)
        {
            item.Valid = true;
            break;
        }
    }
}

// Increment progress 
i = i + 1;
if (i % 5 == 0)
{
    progressValue.Report(i);
    progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
}


#############################################################


int i = 0;
var tasks = new List<Task>();
foreach (var item in items)
{
    tasks.Add(Task.Run(() =>
    {
        try
        {
            using (OSGeo.GDAL.Dataset ds = OSGeo.GDAL.Gdal.Open(item.MaskWcsUrl, OSGeo.GDAL.Access.GA_ReadOnly))
            {
                int width = ds.RasterXSize;
                int height = ds.RasterYSize;
                int size = width * height;

                OSGeo.GDAL.Band band = ds.GetRasterBand(1);

                Int16[] bits = new Int16[size];
                band.ReadRaster(0, 0, width, height, bits, width, height, 0, 0);

                var currentCounts = bits.GroupBy(e => e).Select(x => new { Key = x.Key, Value = x.Count() });

                float numValid = currentCounts.Where(e => validClasses.Contains(e.Key)).Sum(e => e.Value);
                float numOverlap = currentCounts.Where(e => e.Key == 0).Sum(e => e.Value);
                float numTotal = bits.Length;

                float pctValid = numValid / (numTotal - numOverlap);
                float pctOverlap = numOverlap / numTotal;

                // Construct output result
                var result = new Dictionary<string, float>()
                {
                    {"pctValid", pctValid >= 0 ? pctValid : 0},
                    {"pctOverlap", pctOverlap >= 0 ? pctOverlap : 0},
                };

                Debug.WriteLine($"Success on {item.Id}");
                item.Valid = true;
            };
        }
        catch
        {
            Debug.WriteLine($"Error on {item.Id}");
            item.Valid = false;
        }

        // Increment progress 
        i = i + 1;
        if (i % 5 == 0)
        {
            progressValue.Report(i);
            progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
        }
    }));
}

var timer = new Stopwatch();
timer.Start();

await Task.WhenAll(tasks);

timer.Stop();
var duration = timer.Elapsed;
return;


###########################################################
this one keeps ui and allows for num cores, but takes 3x longr than task.whenall
int i = 0;
await QueuedTask.Run(() => Parallel.ForEachAsync(items, paraDownloadOptions, async (item, token) =>
{
    await Task.Run(() =>
    {
    try
    {
        using (OSGeo.GDAL.Dataset ds = OSGeo.GDAL.Gdal.Open(item.MaskWcsUrl, OSGeo.GDAL.Access.GA_ReadOnly))
        {
            int width = ds.RasterXSize;
            int height = ds.RasterYSize;
            int size = width * height;

            OSGeo.GDAL.Band band = ds.GetRasterBand(1);

            Int16[] bits = new Int16[size];
            band.ReadRaster(0, 0, width, height, bits, width, height, 0, 0);

            var currentCounts = bits.GroupBy(e => e).Select(x => new { Key = x.Key, Value = x.Count() });

            float numValid = currentCounts.Where(e => validClasses.Contains(e.Key)).Sum(e => e.Value);
            float numOverlap = currentCounts.Where(e => e.Key == 0).Sum(e => e.Value);
            float numTotal = bits.Length;

            float pctValid = numValid / (numTotal - numOverlap);
            float pctOverlap = numOverlap / numTotal;

            // Construct output result
            var result = new Dictionary<string, float>()
            {
                { "pctValid", pctValid >= 0 ? pctValid : 0 },
                { "pctOverlap", pctOverlap >= 0 ? pctOverlap : 0 },
            };

            Debug.WriteLine($"Success on {item.Id}");
            item.Valid = true;
        };
    }
    catch
    {
        Debug.WriteLine($"Error on {item.Id}");
        item.Valid = false;
    }

    });

    // Increment progress 
    i = i + 1;
    if (i % 5 == 0)
    {
        progressValue.Report(i);
        progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
    }
}));


timer.Stop();
var duration = timer.Elapsed;
return;



//#region Set invalid pixels to NoData and write to final output folder
//// Set progressor
//RefreshProgressBar(1, items.Count, "Processing satellite data...", false);
//ProgressPercentage = "";

//// Establish connection to final output folder
//Uri outputUri = new Uri(outputFolder);
//FileSystemConnectionPath outConn = new FileSystemConnectionPath(outputUri, FileSystemDatastoreType.Raster);

//i = 0;
//await QueuedTask.Run(() => Parallel.ForEachAsync(items, paraProcessingOptions, async (item, token) =>
//{
//    // Open store to temp folder then open raster
//    var store = new FileSystemDatastore(tmpConn);
//    var rasterDs = store.OpenDataset<RasterDataset>(item.FullFilename);
//    var raster = rasterDs.CreateFullRaster();


//    // TODO: testing
//    //Raster indexRaster = rasterDs.CreateRaster(new List<int> { 0 });
//    //var indexRaster = Data.CalculateIndex(raster, rasterDs, "ndvi");
//    //var idxStore = new FileSystemDatastore(outConn);
//    //indexRaster.SaveAs("_mask_" + item.FinalFilename, idxStore, "TIFF");


//    // Using mask band, set all pixel values to nodata where invalid
//    int maskIndex = rasterDs.GetBandIndex("oa_fmask");
//    raster = Data.MaskRasterInvalidPixels(raster, maskIndex, validClasses, noDataValue);

//    // Set store to output folder and save processed raster
//    var outStore = new FileSystemDatastore(outConn);
//    raster.SaveAs("_" + item.FinalFilename, outStore, "TIFF");


//    // TODO: drop oa_fmask band
//    // TODO: Delete image for current item

//    // Increment progress 
//    i = i + 1;
//    if (i % 5 == 0)
//    {
//        progressValue.Report(i);
//        progressPercent.Report($"{Convert.ToInt32(i / MaxProgressValue * 100)}%");
//    }
//}));
//#endregion


//
var roots = root.Features.Select(e => e.Assets["nbart_red"].Href).ToList();
MaxProgressValue = roots.Count;
int j = 0;
await QueuedTask.Run(() => Parallel.ForEachAsync(roots, numCores, async (item, token) =>
{
    await Task.Run(() => { 
        Debug.WriteLine($"Working on {item}");

        string url = item.Remove(0, 5);
        url = "/vsis3_streaming/" + url;

        var watch = new Stopwatch();
        watch.Start();

        OSGeo.GDAL.Dataset dataset = OSGeo.GDAL.Gdal.Open(url, OSGeo.GDAL.Access.GA_ReadOnly);
        OSGeo.GDAL.Band band = dataset.GetRasterBand(1);

        int width = band.XSize;
        int height = band.YSize;
        int size = width * height;

        // Read pixel values into "block" array
        Int16[] bits = new Int16[size];
        band.ReadRaster(0, 0, width, height, bits, width, height, 0, 0);

        watch.Stop();
        var duration = watch.Elapsed;

        Debug.WriteLine($"Took: {duration.ToString()}");
    });

    // Increment progress 
    j = j + 1;
    if (j % 5 == 0)
    {
        progressValue.Report(j);
        progressPercent.Report($"{Convert.ToInt32(j / MaxProgressValue * 100)}%");
    }
}));

public async Task<int> DownloadMaskAsync(string folder, HttpClient client)
{
    // Put this in viewmodel end
    //await QueuedTask.Run(async () =>
    //{
    //    List<Task<int>> masks = items.Select(e => e.DownloadMaskAsync(tmpFolder, client)).ToList();
    //    while (masks.Any())
    //    {
    //        // Get next task when available
    //        Task<int> finished = await Task.WhenAny(masks);
    //        masks.Remove(finished);

    //        // Download mask geotiff
    //        i += await finished;

    //        // Increment progressor
    //        await Task.Delay(100);
    //        progressValue.Report(i);
    //        progressPercent.Report($"({Math.Round(i / MaxProgressValue * 100, 2)}%)");
    //    }
    //});

    string filepath = Path.Join(folder, MaskFilename);

    using (var response = await client.GetAsync(MaskWcsUrl))
    {
        response.EnsureSuccessStatusCode();

        using (FileStream fs = new FileStream(filepath, FileMode.CreateNew))
        {
            await response.Content.CopyToAsync(fs);
            return 1;
        }
    };
}

public async Task<int> DownloadFullAsync(string folder, HttpClient client)
{
    // Put this in viewmodel
    //i = 0;
    //await QueuedTask.Run(async () =>
    //{
    //    List<Task<int>> fulls = items.Select(e => e.DownloadFullAsync(tmpFolder, client)).ToList();
    //    while (fulls.Any())
    //    {
    //        // Get next task when available
    //        Task<int> finish = await Task.WhenAny(fulls);
    //        fulls.Remove(finish);

    //        // Download full geotiff task
    //        i += await finish;

    //        // Increment progressor
    //        await Task.Delay(100);
    //        progressValue.Report(i);
    //        progressPercent.Report($"({Math.Round(i / MaxProgressValue * 100, 2)}%)");
    //    }
    //});

    string filepath = Path.Join(folder, FullFilename);

    using (var response = await client.GetAsync(FullWcsUrl))
    {
        response.EnsureSuccessStatusCode();

        using (FileStream fs = new FileStream(filepath, FileMode.CreateNew))
        {
            await response.Content.CopyToAsync(fs);
            return 1;
        }
    };
}

public async Task Test(string index, string outputFolder, List<int> validPixels, Int16 noDataValue, HttpClient client)
{
    await Task.Run(() =>
    {
        try
        {
            // Create full output path and filename
            //string outputFile = Path.Combine(outputFolder, FinalFilename);

            // Download and read WCS full source raster (including mask band)
            //OSGeo.GDAL.Dataset sourceDS = OSGeo.GDAL.Gdal.Open(FullWcsUrl, OSGeo.GDAL.Access.GA_ReadOnly);

            //OSGeo.GDAL.Driver driver = OSGeo.GDAL.Gdal.GetDriverByName("VRT");

            //OSGeo.GDAL.Dataset dataset = OSGeo.GDAL.Gdal.OpenShared(FullWcsUrl, OSGeo.GDAL.Access.GA_ReadOnly);

            //OSGeo.GDAL.Dataset vrt = driver.CreateCopy(@"C:\Users\262272G\Desktop\out.vrt", dataset, 0, null, null, null);

            //OSGeo.GDAL.Dataset vrt = driver.CreateCopy("", dataset, 0, null, null, null);
            //string xmlvrt = vrt.GetMetadata("xml:VRT")[0];

            //OSGeo.GDAL.Dataset vrt = driver.CreateCopy("", dataset, 0, null, null, null);
            //vrt.SetMetadataItem("SourceDate", "July 21, 2003", "");
            //vrt.GetRasterBand(1)->SetMetadataItem("HideNoDataValue", "1", "");
            //vrt.GetRasterBand(1).SetNoDataValue(-999.0);
            //OSGeo.GDAL.Driver geoTiffdriver = OSGeo.GDAL.Gdal.GetDriverByName("GTiff");
            //OSGeo.GDAL.Dataset geoTiffdataset = geoTiffdriver.CreateCopy("vrt.tif", vrt, 0, null, null, null);
            //geoTiffdataset.FlushCache();
            //geoTiffdataset.Dispose();

            //OSGeo.GDAL.Dataset vrt = driver.CreateCopy("", dataset, 0, null, null, null);
            //vrt.AddBand(OSGeo.GDAL.DataType.GDT_CFloat32, null);


            int z = 0;

        }
        catch (Exception ex)
        {
            int t = 0;
        }

        // Take a breath...
        Task.Delay(100);
    });
}


//OSGeo.GDAL.Gdal.SetConfigOption("AWS_NO_SIGN_REQUEST", "YES");
//OSGeo.GDAL.Gdal.SetConfigOption("VSI_CACHE", "TRUE");
//OSGeo.GDAL.Gdal.SetConfigOption("VSI_CACHE_SIZE ", Math.Pow(10, 9).ToString());
//OSGeo.GDAL.Gdal.SetConfigOption("GDAL_DISABLE_READDIR_ON_OPEN", "EMPTY_DIR");